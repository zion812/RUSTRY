package com.rio.rustry.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.rio.rustry.data.model.Fowl
import com.rio.rustry.domain.model.Result
import com.rio.rustry.domain.usecase.*
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import android.util.Log

/**
 * Modernized ViewModel for Fowl/Flock management with proper coroutine coordination
 * 
 * Features:
 * - Coordinated data loading with combine operators
 * - Proper error handling with Result wrapper
 * - Debounced search functionality
 * - Synchronized state updates
 * - Memory leak prevention
 */
class ModernFlockViewModel(
    private val getFowlsUseCase: GetFowlsUseCase,
    private val addFowlUseCase: AddFowlUseCase,
    private val updateFowlUseCase: UpdateFowlUseCase,
    private val deleteFowlUseCase: DeleteFowlUseCase,
    private val searchFowlsUseCase: SearchFowlsUseCase
) : ViewModel() {
    
    companion object {
        private const val TAG = "ModernFlockViewModel"
        private const val SEARCH_DEBOUNCE_MS = 300L
    }
    
    // State management with proper synchronization
    private val stateMutex = Mutex()
    private var searchJob: Job? = null
    
    // UI State
    private val _uiState = MutableStateFlow(ModernFlockUiState())
    val uiState: StateFlow<ModernFlockUiState> = _uiState.asStateFlow()
    
    // Search query flow for debouncing
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    // Filter states
    private val _selectedBreed = MutableStateFlow<String?>(null)
    private val _selectedOwner = MutableStateFlow<String?>(null)
    private val _priceRange = MutableStateFlow(PriceRange(0.0, Double.MAX_VALUE))
    
    /**
     * Combined fowls flow with coordinated data loading
     * Combines search, filters, and base data using proper operators
     */
    val fowls: StateFlow<Result<List<Fowl>>> = combine(
        _searchQuery.debounce(SEARCH_DEBOUNCE_MS).distinctUntilChanged(),
        _selectedBreed,
        _selectedOwner,
        _priceRange
    ) { query, breed, owner, priceRange ->
        CoordinatedQuery(query, breed, owner, priceRange)
    }.flatMapLatest { coordinatedQuery ->
        when {
            coordinatedQuery.searchQuery.isNotBlank() -> {
                searchFowlsUseCase.searchImmediate(coordinatedQuery.searchQuery)
            }
            coordinatedQuery.breed != null -> {
                getFowlsUseCase.byBreed(coordinatedQuery.breed)
            }
            coordinatedQuery.owner != null -> {
                getFowlsUseCase.byOwner(coordinatedQuery.owner)
            }
            coordinatedQuery.priceRange.min > 0.0 || coordinatedQuery.priceRange.max < Double.MAX_VALUE -> {
                getFowlsUseCase.byPriceRange(coordinatedQuery.priceRange.min, coordinatedQuery.priceRange.max)
            }
            else -> {
                getFowlsUseCase()
            }
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = Result.Loading
    )
    
    /**
     * Statistics derived from fowls data
     */
    val statistics: StateFlow<FowlStatistics> = fowls
        .map { result ->
            when (result) {
                is Result.Success -> calculateStatistics(result.data)
                else -> FowlStatistics()
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = FowlStatistics()
        )
    
    /**
     * Available fowls for marketplace
     */
    val availableFowls: StateFlow<Result<List<Fowl>>> = getFowlsUseCase.available()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = Result.Loading
        )
    
    /**
     * Search fowls with proper debouncing
     */
    fun searchFowls(query: String) {
        _searchQuery.value = query.trim()
    }
    
    /**
     * Filter by breed with coordination
     */
    fun filterByBreed(breed: String?) {
        viewModelScope.launch {
            stateMutex.withLock {
                _selectedBreed.value = breed
                // Clear other filters when breed is selected
                if (breed != null) {
                    _selectedOwner.value = null
                    _searchQuery.value = ""
                }
            }
        }
    }
    
    /**
     * Filter by owner with coordination
     */
    fun filterByOwner(ownerId: String?) {
        viewModelScope.launch {
            stateMutex.withLock {
                _selectedOwner.value = ownerId
                // Clear other filters when owner is selected
                if (ownerId != null) {
                    _selectedBreed.value = null
                    _searchQuery.value = ""
                }
            }
        }
    }
    
    /**
     * Filter by price range with coordination
     */
    fun filterByPriceRange(minPrice: Double, maxPrice: Double) {
        viewModelScope.launch {
            stateMutex.withLock {
                _priceRange.value = PriceRange(minPrice, maxPrice)
                // Clear other filters when price range is set
                if (minPrice > 0.0 || maxPrice < Double.MAX_VALUE) {
                    _selectedBreed.value = null
                    _selectedOwner.value = null
                    _searchQuery.value = ""
                }
            }
        }
    }
    
    /**
     * Clear all filters with coordination
     */
    fun clearFilters() {
        viewModelScope.launch {
            stateMutex.withLock {
                _searchQuery.value = ""
                _selectedBreed.value = null
                _selectedOwner.value = null
                _priceRange.value = PriceRange(0.0, Double.MAX_VALUE)
            }
        }
    }
    
    /**
     * Add fowl with proper error handling
     */
    fun addFowl(fowl: Fowl) {
        viewModelScope.launch {
            try {
                updateUiState { it.copy(isLoading = true, error = null) }
                
                val result = addFowlUseCase.invoke(fowl)
                
                result.onSuccess {
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            successMessage = "Fowl added successfully"
                        ) 
                    }
                }.onError { exception ->
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            error = exception.message ?: "Failed to add fowl"
                        ) 
                    }
                }
                
            } catch (exception: Exception) {
                Log.e(TAG, "Error adding fowl", exception)
                updateUiState { 
                    it.copy(
                        isLoading = false, 
                        error = exception.message ?: "Unexpected error occurred"
                    ) 
                }
            }
        }
    }
    
    /**
     * Update fowl with optimistic updates
     */
    fun updateFowl(fowl: Fowl) {
        viewModelScope.launch {
            try {
                updateUiState { it.copy(isLoading = true, error = null) }
                
                val result = updateFowlUseCase.invoke(fowl)
                
                result.onSuccess {
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            successMessage = "Fowl updated successfully"
                        ) 
                    }
                }.onError { exception ->
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            error = exception.message ?: "Failed to update fowl"
                        ) 
                    }
                }
                
            } catch (exception: Exception) {
                Log.e(TAG, "Error updating fowl", exception)
                updateUiState { 
                    it.copy(
                        isLoading = false, 
                        error = exception.message ?: "Unexpected error occurred"
                    ) 
                }
            }
        }
    }
    
    /**
     * Delete fowl with confirmation
     */
    fun deleteFowl(fowlId: String) {
        viewModelScope.launch {
            try {
                updateUiState { it.copy(isLoading = true, error = null) }
                
                val result = deleteFowlUseCase.invoke(fowlId)
                
                result.onSuccess {
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            successMessage = "Fowl deleted successfully"
                        ) 
                    }
                }.onError { exception ->
                    updateUiState { 
                        it.copy(
                            isLoading = false, 
                            error = exception.message ?: "Failed to delete fowl"
                        ) 
                    }
                }
                
            } catch (exception: Exception) {
                Log.e(TAG, "Error deleting fowl", exception)
                updateUiState { 
                    it.copy(
                        isLoading = false, 
                        error = exception.message ?: "Unexpected error occurred"
                    ) 
                }
            }
        }
    }
    
    /**
     * Refresh data with proper coordination
     */
    fun refreshData() {
        viewModelScope.launch {
            try {
                updateUiState { it.copy(isRefreshing = true, error = null) }
                
                // Trigger refresh by clearing and reloading
                clearFilters()
                
                // Add small delay to show refresh indicator
                delay(500)
                
                updateUiState { it.copy(isRefreshing = false) }
                
            } catch (exception: Exception) {
                Log.e(TAG, "Error refreshing data", exception)
                updateUiState { 
                    it.copy(
                        isRefreshing = false, 
                        error = exception.message ?: "Failed to refresh data"
                    ) 
                }
            }
        }
    }
    
    /**
     * Clear error message
     */
    fun clearError() {
        updateUiState { it.copy(error = null) }
    }
    
    /**
     * Clear success message
     */
    fun clearSuccessMessage() {
        updateUiState { it.copy(successMessage = null) }
    }
    
    /**
     * Thread-safe UI state updates
     */
    private fun updateUiState(update: (ModernFlockUiState) -> ModernFlockUiState) {
        _uiState.value = update(_uiState.value)
    }
    
    /**
     * Calculate statistics from fowl list
     */
    private fun calculateStatistics(fowls: List<Fowl>): FowlStatistics {
        return FowlStatistics(
            totalFowls = fowls.size,
            totalValue = fowls.sumOf { it.price },
            availableForSale = fowls.count { it.isForSale && it.isAvailable },
            averagePrice = if (fowls.isNotEmpty()) fowls.map { it.price }.average() else 0.0,
            breedDistribution = fowls.groupBy { it.breed }.mapValues { it.value.size },
            healthStatusDistribution = fowls.groupBy { it.healthStatus ?: "Unknown" }.mapValues { it.value.size }
        )
    }
    
    /**
     * Cancel search job when ViewModel is cleared
     */
    override fun onCleared() {
        super.onCleared()
        searchJob?.cancel()
    }
}

/**
 * Data classes for coordinated queries and state management
 */
data class CoordinatedQuery(
    val searchQuery: String,
    val breed: String?,
    val owner: String?,
    val priceRange: PriceRange
)

data class PriceRange(
    val min: Double,
    val max: Double
)

/**
 * Modern UI State with comprehensive state management
 */
data class ModernFlockUiState(
    val isLoading: Boolean = false,
    val isRefreshing: Boolean = false,
    val error: String? = null,
    val successMessage: String? = null
)

/**
 * Statistics data class
 */
data class FowlStatistics(
    val totalFowls: Int = 0,
    val totalValue: Double = 0.0,
    val availableForSale: Int = 0,
    val averagePrice: Double = 0.0,
    val breedDistribution: Map<String, Int> = emptyMap(),
    val healthStatusDistribution: Map<String, Int> = emptyMap()
)