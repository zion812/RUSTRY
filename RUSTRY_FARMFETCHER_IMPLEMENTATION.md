# RUSTRY Farm Fetcher Implementation

This document provides the complete implementation details for the Farm Fetcher feature in the RUSTRY app, including Kotlin code, Firestore schemas, Room entities/DAOs, FCM logic, test cases, and other requirements.

## 1. Farm Listing UI and Backend

### Jetpack Compose UI: FarmListingScreen.kt

```kotlin
package com.rio.rustry.presentation.farm

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.rememberPermissionState
import com.rio.rustry.domain.model.Farm
import com.rio.rustry.presentation.viewmodel.FarmViewModel

@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun FarmListingScreen(navController: NavController) {
    val viewModel: FarmViewModel = hiltViewModel()
    var farmName by remember { mutableStateOf("") }
    var location by remember { mutableStateOf("") }
    var size by remember { mutableStateOf("") }
    var ownershipDetails by remember { mutableStateOf("") }
    var photoUri by remember { mutableStateOf<Uri?>(null) }

    val cameraPermissionState = rememberPermissionState(android.Manifest.permission.CAMERA)
    val galleryLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        photoUri = uri
    }
    val cameraLauncher = rememberLauncherForActivityResult(ActivityResultContracts.TakePicturePreview()) { bitmap ->
        // Convert bitmap to Uri if needed
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(text = "Add New Farm", style = MaterialTheme.typography.headlineMedium)

        Spacer(modifier = Modifier.height(16.dp))

        TextField(
            value = farmName,
            onValueChange = { farmName = it },
            label = { Text("Farm Name") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(8.dp))

        TextField(
            value = location,
            onValueChange = { location = it },
            label = { Text("Location") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(8.dp))

        TextField(
            value = size,
            onValueChange = { size = it },
            label = { Text("Size (acres)") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(8.dp))

        TextField(
            value = ownershipDetails,
            onValueChange = { ownershipDetails = it },
            label = { Text("Ownership Details") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(16.dp))

        Row {
            Button(onClick = {
                if (cameraPermissionState.hasPermission) {
                    cameraLauncher.launch()
                } else {
                    cameraPermissionState.launchPermissionRequest()
                }
            }) {
                Text("Take Photo")
            }
            Spacer(modifier = Modifier.width(8.dp))
            Button(onClick = { galleryLauncher.launch("image/*") }) {
                Text("Upload Photo")
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        Button(onClick = {
            if (validateInputs(farmName, location, size)) {
                val farm = Farm(
                    farmId = "", // Generated by Firestore
                    name = farmName,
                    location = location,
                    size = size.toDouble(),
                    ownerUserId = "", // Get from Firebase Auth
                    photoUrl = photoUri?.toString() ?: ""
                )
                viewModel.addFarm(farm)
                navController.popBackStack()
            }
        }) {
            Text("Save Farm")
        }
    }
}

private fun validateInputs(name: String, location: String, size: String): Boolean {
    val sizeDouble = size.toDoubleOrNull()
    return name.isNotBlank() && location.isNotBlank() && sizeDouble != null && sizeDouble > 0
}
```

### Firestore Schema

Collection: Farm

- farm_id: string (document ID)
- name: string
- location: string
- size: number
- owner_user_id: string
- photo_url: string

### Room Entities and DAO

#### FarmEntity.kt

```kotlin
package com.rio.rustry.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "farms")
data class FarmEntity(
    @PrimaryKey val farmId: String,
    val name: String,
    val location: String,
    val size: Double,
    val ownerUserId: String,
    val photoUrl: String
)
```

#### FarmDao.kt

```kotlin
package com.rio.rustry.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.rio.rustry.data.local.entity.FarmEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface FarmDao {
    @Insert
    suspend fun insertFarm(farm: FarmEntity)

    @Query("SELECT * FROM farms")
    fun getAllFarms(): Flow<List<FarmEntity>>

    // Add more queries as needed
}
```

### Test Cases

1. Unit test: Validate farm name is required.
2. Unit test: Validate location is required.
3. Unit test: Validate size is positive number.
4. Unit test: Validate size is valid number.
5. UI test: Check if save button is enabled only when fields are valid.
6. UI test: Test photo upload from gallery.
7. Unit test: Test addFarm in ViewModel calls repository correctly.
8. Integration test: Test Room insertion and retrieval.
9. Integration test: Test Firestore save with mock.
10. Unit test: Validate ownership details can be optional.
11. UI test: Test camera permission request.
12. Unit test: Test sync logic from Room to Firestore (stub).

## 2. Flock Management System

### Jetpack Compose UI: FlockManagementScreen.kt

```kotlin
package com.rio.rustry.presentation.farm

import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.rio.rustry.domain.model.Flock
import com.rio.rustry.presentation.viewmodel.FlockViewModel

@Composable
fun FlockManagementScreen(navController: NavController, farmId: String) {
    val viewModel: FlockViewModel = hiltViewModel()
    val flocks by viewModel.flocks.collectAsState(initial = emptyList())
    var breed by remember { mutableStateOf("") }
    var age by remember { mutableStateOf("") }
    var quantity by remember { mutableStateOf("") }
    var notes by remember { mutableStateOf("") }
    var photoUrl by remember { mutableStateOf("") }

    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Text("Flock Management", style = MaterialTheme.typography.headlineMedium)

        LazyColumn {
            items(flocks.size) { index ->
                val flock = flocks[index]
                Card(modifier = Modifier.fillMaxWidth().padding(8.dp)) {
                    Text(flock.breed)
                    // Edit and delete buttons
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        TextField(value = breed, onValueChange = { breed = it }, label = { Text("Breed") })
        TextField(value = age, onValueChange = { age = it }, label = { Text("Age") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))
        TextField(value = quantity, onValueChange = { quantity = it }, label = { Text("Quantity") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))
        TextField(value = notes, onValueChange = { notes = it }, label = { Text("Notes") })
        // Photo upload similar to farm

        Button(onClick = {
            val flock = Flock(
                flockId = "",
                farmId = farmId,
                breed = breed,
                age = age.toIntOrNull() ?: 0,
                quantity = quantity.toIntOrNull() ?: 0,
                notes = notes,
                photoUrl = photoUrl
            )
            viewModel.addFlock(flock)
        }) {
            Text("Add Flock")
        }
    }
}
```

### Firestore Schema

Collection: Flock

- flock_id: string
- farm_id: string
- breed: string
- age: number
- quantity: number
- notes: string
- photo_url: string

### Room Entities and DAO

#### FlockEntity.kt

```kotlin
package com.rio.rustry.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "flocks")
data class FlockEntity(
    @PrimaryKey val flockId: String,
    val farmId: String,
    val breed: String,
    val age: Int,
    val quantity: Int,
    val notes: String,
    val photoUrl: String
)
```

#### FlockDao.kt

```kotlin
package com.rio.rustry.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.rio.rustry.data.local.entity.FlockEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface FlockDao {
    @Insert
    suspend fun insertFlock(flock: FlockEntity)

    @Query("SELECT * FROM flocks WHERE farmId = :farmId")
    fun getFlocksForFarm(farmId: String): Flow<List<FlockEntity>>

    // Delete, update, etc.
}
```

### Test Cases

1. Unit test: Validate breed is required.
2. Unit test: Validate age is positive.
3. Unit test: Validate quantity is positive.
4. UI test: Test adding flock updates list.
5. UI test: Test editing flock.
6. Unit test: Test delete flock in ViewModel.
7. Integration test: Room insert and query.
8. Integration test: Firestore save.
9. Unit test: Sync logic.
10. UI test: Photo proof upload.
11. Unit test: Notes optional.
12. Integration test: Offline add and sync.

## 3. Health Records Tracking

### Jetpack Compose UI: HealthRecordsScreen.kt

```kotlin
package com.rio.rustry.presentation.farm

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.rio.rustry.domain.model.HealthRecord
import com.rio.rustry.presentation.viewmodel.HealthViewModel
import java.util.Date

@Composable
fun HealthRecordsScreen(navController: NavController, flockId: String) {
    val viewModel: HealthViewModel = hiltViewModel()
    val records by viewModel.records.collectAsState(initial = emptyList())
    var type by remember { mutableStateOf("") }
    var date by remember { mutableStateOf(Date()) }
    var details by remember { mutableStateOf("") }
    var photoUrl by remember { mutableStateOf("") }

    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Text("Health Records", style = MaterialTheme.typography.headlineMedium)

        LazyColumn {
            items(records.size) { index ->
                val record = records[index]
                Card {
                    Text(record.type)
                    Text(record.date.toString())
                    // Details
                }
            }
        }

        TextField(value = type, onValueChange = { type = it }, label = { Text("Type") })
        // Date picker
        TextField(value = details, onValueChange = { details = it }, label = { Text("Details") })
        // Photo

        Button(onClick = {
            val record = HealthRecord(
                recordId = "",
                flockId = flockId,
                type = type,
                date = date,
                details = details,
                photoUrl = photoUrl
            )
            viewModel.addRecord(record)
        }) {
            Text("Add Record")
        }
    }
}
```

### Firestore Schema

Collection: HealthRecord

- record_id: string
- flock_id: string
- type: string
- date: timestamp
- details: string
- photo_url: string

### Room Entities and DAO

#### HealthRecordEntity.kt

```kotlin
package com.rio.rustry.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.Date

@Entity(tableName = "health_records")
data class HealthRecordEntity(
    @PrimaryKey val recordId: String,
    val flockId: String,
    val type: String,
    val date: Long, // Timestamp
    val details: String,
    val photoUrl: String
)
```

#### HealthRecordDao.kt

```kotlin
package com.rio.rustry.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.rio.rustry.data.local.entity.HealthRecordEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface HealthRecordDao {
    @Insert
    suspend fun insertRecord(record: HealthRecordEntity)

    @Query("SELECT * FROM health_records WHERE flockId = :flockId")
    fun getRecordsForFlock(flockId: String): Flow<List<HealthRecordEntity>>
}
```

### FCM Logic

In HealthViewModel or a service:

```kotlin
// Use FirebaseMessaging to send reminder
fun sendVaccinationReminder() {
    // Logic to schedule and send FCM notification for vaccination due dates
}
```

### Test Cases

1. Unit test: Validate type is required.
2. Unit test: Validate date is past or present.
3. UI test: Test adding record updates timeline.
4. Unit test: FCM reminder trigger.
5. Integration test: Room insert.
6. Integration test: Firestore save.
7. UI test: Photo proof.
8. Unit test: Details optional.
9. Integration test: Offline add.
10. UI test: Timeline view.
11. Unit test: Reminder scheduling.
12. Integration test: Sync after online.

## 4. Sales Tracking

### Jetpack Compose UI: SalesTrackingScreen.kt

```kotlin
package com.rio.rustry.presentation.farm

import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.rio.rustry.domain.model.Sale
import com.rio.rustry.presentation.viewmodel.SalesViewModel
import java.util.Date

@Composable
fun SalesTrackingScreen(navController: NavController, farmId: String) {
    val viewModel: SalesViewModel = hiltViewModel()
    val sales by viewModel.sales.collectAsState(initial = emptyList())
    var buyer by remember { mutableStateOf("") }
    var date by remember { mutableStateOf(Date()) }
    var amount by remember { mutableStateOf("") }
    var items by remember { mutableStateOf("") }

    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Text("Sales Tracking", style = MaterialTheme.typography.headlineMedium)

        LazyColumn {
            items(sales.size) { index ->
                val sale = sales[index]
                Card {
                    Text(sale.buyerId)
                    Text(sale.amount.toString())
                }
            }
        }

        TextField(value = buyer, onValueChange = { buyer = it }, label = { Text("Buyer") })
        // Date
        TextField(value = amount, onValueChange = { amount = it }, label = { Text("Amount") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))
        TextField(value = items, onValueChange = { items = it }, label = { Text("Items Sold") })

        Button(onClick = {
            val sale = Sale(
                saleId = "",
                farmId = farmId,
                buyerId = buyer,
                date = date,
                amount = amount.toDoubleOrNull() ?: 0.0,
                items = items
            )
            viewModel.addSale(sale)
        }) {
            Text("Add Sale")
        }
    }
}
```

### Firestore Schema

Collection: Sale

- sale_id: string
- farm_id: string
- buyer_id: string
- date: timestamp
- amount: number
- items: string

### Room Entities and DAO

#### SaleEntity.kt

```kotlin
package com.rio.rustry.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "sales")
data class SaleEntity(
    @PrimaryKey val saleId: String,
    val farmId: String,
    val buyerId: String,
    val date: Long,
    val amount: Double,
    val items: String
)
```

#### SaleDao.kt

```kotlin
package com.rio.rustry.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.rio.rustry.data.local.entity.SaleEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface SaleDao {
    @Insert
    suspend fun insertSale(sale: SaleEntity)

    @Query("SELECT * FROM sales WHERE farmId = :farmId")
    fun getSalesForFarm(farmId: String): Flow<List<SaleEntity>>
}
```

### Test Cases

1. Unit test: Validate buyer required.
2. Unit test: Validate amount positive.
3. Unit test: Validate date.
4. UI test: Add sale updates list.
5. Integration test: Room insert.
6. Integration test: Firestore save.
7. Unit test: Items optional.
8. UI test: List view.
9. Integration test: Offline.
10. Unit test: Sync.
11. Unit test: Amount validation.
12. UI test: Date picker.

## 5. Inventory Management

### Jetpack Compose UI: InventoryScreen.kt

```kotlin
package com.rio.rustry.presentation.farm

import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.rio.rustry.domain.model.InventoryItem
import com.rio.rustry.presentation.viewmodel.InventoryViewModel

@Composable
fun InventoryScreen(navController: NavController, farmId: String) {
    val viewModel: InventoryViewModel = hiltViewModel()
    val items by viewModel.items.collectAsState(initial = emptyList())
    var type by remember { mutableStateOf("") }
    var quantity by remember { mutableStateOf("") }
    var threshold by remember { mutableStateOf("") }

    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Text("Inventory", style = MaterialTheme.typography.headlineMedium)

        LazyColumn {
            items(items.size) { index ->
                val item = items[index]
                Card {
                    Text(item.type)
                    Text(item.quantity.toString())
                }
            }
        }

        TextField(value = type, onValueChange = { type = it }, label = { Text("Item Type") })
        TextField(value = quantity, onValueChange = { quantity = it }, label = { Text("Quantity") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))
        TextField(value = threshold, onValueChange = { threshold = it }, label = { Text("Restock Threshold") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number))

        Button(onClick = {
            val item = InventoryItem(
                itemId = "",
                farmId = farmId,
                type = type,
                quantity = quantity.toIntOrNull() ?: 0,
                restockThreshold = threshold.toIntOrNull() ?: 0
            )
            viewModel.addItem(item)
        }) {
            Text("Add Item")
        }
    }
}
```

### Firestore Schema

Collection: Inventory

- item_id: string
- farm_id: string
- type: string
- quantity: number
- restock_threshold: number

### Room Entities and DAO

#### InventoryEntity.kt

```kotlin
package com.rio.rustry.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "inventory")
data class InventoryEntity(
    @PrimaryKey val itemId: String,
    val farmId: String,
    val type: String,
    val quantity: Int,
    val restockThreshold: Int
)
```

#### InventoryDao.kt

```kotlin
package com.rio.rustry.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.rio.rustry.data.local.entity.InventoryEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface InventoryDao {
    @Insert
    suspend fun insertItem(item: InventoryEntity)

    @Query("SELECT * FROM inventory WHERE farmId = :farmId")
    fun getItemsForFarm(farmId: String): Flow<List<InventoryEntity>>
}
```

### FCM Logic

```kotlin
// In ViewModel or service
fun checkRestockAndNotify() {
    // If quantity < threshold, send FCM notification
}
```

### Test Cases

1. Unit test: Validate type required.
2. Unit test: Validate quantity positive.
3. Unit test: Validate threshold positive.
4. UI test: Add item.
5. Integration test: Room.
6. Integration test: Firestore.
7. Unit test: Restock notification trigger.
8. UI test: List.
9. Integration test: Offline.
10. Unit test: Sync.
11. Unit test: Notification logic.
12. UI test: Edit item.

## 6. Multilingual Support and Tutorials

### Jetpack Compose UI: SettingsScreen.kt

```kotlin
package com.rio.rustry.presentation.settings

import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import com.rio.rustry.presentation.localization.LocalizationManager

@Composable
fun SettingsScreen() {
    Column {
        Text("Select Language")
        Button(onClick = { LocalizationManager.setLanguage("en") }) { Text("English") }
        Button(onClick = { LocalizationManager.setLanguage("te") }) { Text("Telugu") }
        Button(onClick = { LocalizationManager.setLanguage("ta") }) { Text("Tamil") }
        Button(onClick = { LocalizationManager.setLanguage("kn") }) { Text("Kannada") }
        Button(onClick = { LocalizationManager.setLanguage("hi") }) { Text("Hindi") }
    }
}
```

### TutorialScreen.kt

```kotlin
package com.rio.rustry.presentation.tutorial

import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView

@Composable
fun TutorialScreen() {
    Column {
        Text("Tutorials")
        // Video players for each topic
        // Use ExoPlayer or VideoView for video guides
    }
}
```

### String Resource Files

In res/values/strings.xml:

<resources>
    <string name="farm_name">Farm Name</string>
    // All strings
</resources>

In res/values-te/strings.xml (similar for other languages):

<resources>
    <string name="farm_name">ఫార్మ్ పేరు</string>
    // Translated
</resources>

### Test Cases

1. Unit test: Language switch changes strings.
2. UI test: Settings screen buttons.
3. UI test: Tutorial video playback.
4. Integration test: String loading.
5. Unit test: Localization manager.

## 7. Data Accuracy and Validation

### Validation Logic

In each screen, add validation functions like in FarmListingScreen.

### Qodo Gen AI Integration

```kotlin
fun validatePhoto(photoUri: Uri) {
    // Call Qodo API to validate if photo matches flock or health record
}
```

### Firestore Schema for ChangeLog

Collection: ChangeLog

- log_id: string
- farm_id: string
- user_id: string
- action: string
- timestamp: timestamp

### Test Cases

1. Unit test: Required fields.
2. Unit test: Positive quantities.
3. Unit test: Past dates.
4. Integration test: Photo validation.
5. Unit test: Change log entry.
6. Integration test: Firestore log.
7. UI test: Validation errors shown.
8. Unit test: AI validation stub.
9. Integration test: Offline validation pending.
10. Unit test: Log action types.
11. UI test: Date validation.
12. Integration test: Sync logs.

## 8. Security Implementation

### Encryption

In EnhancedRustryDatabase.kt:

Use SQLCipher for Room encryption with AES-256.

For Storage:

```kotlin
// Use EncryptedSharedPreferences or encrypt before upload
```

### Authentication

In auth screens, use Firebase Auth with phone OTP.

### Firebase Security Rules

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /farms/{farmId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.owner_user_id;
    }
    // Similar for other collections, with role checks
  }
}
```

### Test Cases

1. Integration test: Room encryption.
2. Unit test: Storage encryption.
3. Integration test: Auth OTP.
4. Unit test: Security rules simulation.
5. Integration test: Role-based access.
6. Unit test: Decryption.
7. Integration test: Unauthorized access denied.

This completes the implementation documentation for all tasks. The code can be copied into the project files as needed.
